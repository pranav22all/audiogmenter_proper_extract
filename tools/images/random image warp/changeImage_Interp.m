%% changeImage_Interp.m

% This function uses a modification of the implementation of the Thin-Plane 
% spline warping available at 
% https://it.mathworks.com/matlabcentral/fileexchange/24315-warping-using-thin-plate-splines

function imgw = changeImage_Interp(IM, xGrid, yGrid, xNoise,numPunti, maxChange)
% CHANGEIMAGE_INTERP computes the reference points (landmarks) in the
% original image IM and in the warped image imgw. The warping performed by 
% tpswarp will translate the landmarks in IM into the landmarks in imgw.
%
% This function
%   1) perturbs numPunti+2 points by translating them on the x axis,
%   accoring to the noise xNoise
%   2) uses the Piecewise Cubic Hermite Interpolating Polynomial (pchip)
%   and the horizontally perturbed numPunti+2 points to apply the
%   horizontal perturbation to all the pixels in IM
%   3)samples the original image IM and the horizontally pertubed image by
%   selecting a subset of pixels every xGrid and yGrid pixels in order to
%   generate the landmarks in the original image IM and in the warped image
%   imgw to be generated by tpswarp.
%
%   imgw = changeImage_Interp(IM, xGrid, yGrid, xNoise,numPunti, maxChange)
%
%   Input
%   IM: original input image
%
%   xGrid: distance between consecutive perturbed pixels in the x axis
%
%   yGrid: distance between consecutive perturbed pixels in the y axis
%
%   xNoise: size of the random perturbation in the x axis
%
%   numPunti: number of points used to generate the perturbation
%
%   maxChange: max radius for nearest neighbor interpolation required by
%       tpswarp
%

% Picks numPunti+2 random points to be horizontally perturbed by xNoise
num=xGrid:xGrid:size(IM,2)-xGrid;
punti=sort(num(randperm(length(num),numPunti)));
x=ones(numPunti+2,1);%posizione inizale pixel
y=ones(numPunti+2,1);%posizione di destianlione pixel
x(numPunti+2)=size(IM,2);
y(numPunti+2)=size(IM,2);
x(2:1:numPunti+1)=punti;

% Random addition or subtraction of xNoise
if round(rand)==0
    sig=1;
else
    sig=-1;
end

% Avoids overlapping of perturbed points
for i=2:1:numPunti+1
    distMin=min([x(i)-x(i-1) x(i+1)-x(i)]);
    if mod(i,2)==0
        if distMin<(2*xNoise)
            y(i)=x(i)+(sig*floor(distMin/4));
        else
            y(i)=x(i)+xNoise;
        end
    else
        if distMin<(2*xNoise)
            y(i)=x(i)-(sig*floor(distMin/4));
        else
            y(i)=x(i)-xNoise;
        end
    end
end

% Points to be horizontally perturbed by means of interpolation
xx=1: 1: size(IM,1);

% Computes interpolation on the points in xx
%yy=spline(x,y,xx);       %interpolazione alternativa
yy=pchip(x,y,xx);         %interpolazione per creare la fuzione che mi sposta i pixel

% Selects the landmark points in the original image IM and in for the
% warped image imgw to be nerated by tpswarp
i = 1;
for row = 1: xGrid: size(IM,1)
    for col = 1: yGrid: size(IM,2)
        Y(i,1) = col;
        Y(i,2) = floor(yy(row)); % perturbation in time (horizontal)
        Z(i,1) = col;
        Z(i,2) = row;
        i = i+1;
    end
end

% tpswarp interpolation options
interp = struct();
interp.method = 'nearest';
interp.radius = maxChange;
interp.power = 1;

% Applies the Thin-Plane spline warping in time
[imgw, imgwr, map] = tpswarp(single(IM),[size(IM,2),size(IM,1)],Z,Y,interp);
end


